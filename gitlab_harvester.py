from __future__ import annotations

import json
import os
from datetime import UTC, datetime
from pathlib import Path
from typing import Any, IO

from glh import CliParser, GitlabHarvester
from glh.planner import ScanOptions
from glh.session import load_done_keywords


def _load_keywords(*, search: str | None, terms_file: str | None) -> list[str]:
    """
    Load search keywords from either a single term or a file.

    Args:
        search: Single search term provided via CLI. Takes precedence over terms_file.
        terms_file: Path to a file containing search terms, one per line. Lines starting
            with '#' and empty lines are ignored.

    Returns:
        A list of normalized keyword strings. Returns an empty list if neither
        search nor terms_file is provided or if no valid keywords were found.
    """
    if search:
        s = search.strip()
        return [s] if s else []

    if terms_file:
        p = Path(terms_file)
        keywords: list[str] = []
        for line in p.read_text(encoding="utf-8").splitlines():
            t = line.strip()
            if t and not t.startswith("#"):
                keywords.append(t)
        return keywords

    return []


def _default_session_name(host: str) -> str:
    """
    Generate a default session name based on the GitLab host and current UTC timestamp.

    The host is normalized by replacing dots with underscores to ensure a filesystem-safe
    name. The timestamp is appended in YYYYMMDDHHMMSS format.

    Args:
        host: GitLab host name (e.g., "gitlab.example.com").

    Returns:
        A string suitable for use as a session identifier and filename prefix.
    """
    safe = host.replace(".", "_")
    ts = datetime.now(UTC).strftime("%Y%m%d%H%M%S")
    return f"{safe}_session_{ts}"


def _resolve_session_path(host: str, session: str | None, session_file: str | None) -> Path:
    """
    Determine the final session output path based on CLI parameters.

    Resolution priority:
        1. session_file — used as an explicit path without modification.
        2. session — treated as a name and converted to "<name>.jsonl".
        3. fallback — autogenerated name based on host and current timestamp.

    Args:
        host: GitLab host name, used for generating the default session name.
        session: Optional session name provided by the user.
        session_file: Optional explicit path to the session file.

    Returns:
        Path object representing the resolved session file location.
    """
    if session_file:
        return Path(session_file)
    if session:
        return Path(f"{session}.jsonl")
    return Path(f"results{os.sep}{_default_session_name(host)}.jsonl")


def _write_jsonl_line(fp: IO, record: dict[str, Any]) -> None:
    """
    Write a single record to a JSONL (NDJSON) file.

    The record is serialized as UTF-8 JSON without ASCII escaping and terminated
    with a newline character to maintain one-object-per-line format.

    Args:
        fp: Open file-like object for writing text data.
        record: Dictionary to serialize and append to the file.

    Returns:
        None
    """
    fp.write(json.dumps(record, ensure_ascii=False) + "\n")


def main(argv: list[str] | None = None) -> None:
    """
    Entry point for the GitLab Harvester CLI.

    The function supports two primary modes:

    1. Dump-only mode (--dump-only):
       Builds or rebuilds the Instance Project Index and exits without performing
       any search operations.

    2. Search mode:
       - Loads search keywords from CLI arguments.
       - Ensures that the project index exists (optionally rebuilding it).
       - Loads projects from the index file.
       - Executes keyword search according to scan options.
       - Writes results to a session JSONL file with support for resume.

    Resume behavior:
       When --resume is provided, the function reads the existing session file,
       filters out already completed keywords, and continues search in append mode.

    Args:
        argv: Optional list of command-line arguments. If None, sys.argv is used.

    Raises:
        SystemExit: If no keywords are provided in search mode or the project index
            is empty.
    """
    args = CliParser.parse(argv)
    glh = GitlabHarvester(host=args.host, token=args.token)

    # --- dump-only: force rebuild by design ---
    if args.dump_only:
        index_file = glh.build_project_index(
            per_page=args.batch_size,
            filename=args.index_file,  # already normalized (may come from --output in dump-only)
            enforce_dump=True,
            branches=args.index_branches,
            branches_per_page=args.branches_per_page,
        )
        print(f"Project index saved to: {index_file}")
        return

    # --- search mode requires a keyword or file ---
    keywords = _load_keywords(search=args.search, terms_file=args.terms_file)
    if not keywords:
        raise SystemExit("Nothing to do: provide --search or --terms-file, or use --dump-only.")

    # --- ensure/build index for search run ---
    index_file = glh.build_project_index(
        per_page=args.batch_size,
        filename=args.index_file,  # explicit --index-file or default
        enforce_dump=args.dump_projects,
        branches=args.index_branches,
        branches_per_page=args.branches_per_page,
    )

    data = glh.load_projects_from_file(index_file)
    projects = data.get("projects", [])
    if not projects:
        raise SystemExit(f"Project index is empty: {index_file}")

    options = ScanOptions(
        scan_branches=args.scan_branches,
        forks_mode=args.forks,
        fork_diff_bases=tuple(x.strip() for x in args.fork_diff_bases.split(",") if x.strip()),
    )

    # --- resolve session output file ---
    session_path = _resolve_session_path(glh.get_host(), args.session, args.session_file)
    session_path.parent.mkdir(parents=True, exist_ok=True)

    done_keywords: set[str] = set()
    if args.resume:
        done_keywords = load_done_keywords(session_path)
        if done_keywords:
            keywords = [k for k in keywords if k not in done_keywords]

        if not keywords:
            print(f"Nothing to resume: all keywords already completed in {session_path}")
            return

    # --- open session file (append for resume, overwrite otherwise) ---
    mode = "a" if args.resume else "w"
    with session_path.open(mode, encoding="utf-8") as sess_fp:
        if args.resume:
            _write_jsonl_line(
                sess_fp,
                {
                    "type": "resume",
                    "timestamp_utc": datetime.now(UTC).isoformat(),
                    "done_keywords": len(done_keywords),
                    "remaining_keywords": len(keywords),
                },
            )
        else:
            _write_jsonl_line(
                sess_fp,
                {
                    "type": "meta",
                    "timestamp_utc": datetime.now(UTC).isoformat(),
                    "host": args.host,
                    "index_file": str(index_file),
                    "batch_size": args.batch_size,
                    "branches_per_page": args.branches_per_page,
                    "index_branches": args.index_branches,
                    "scan_branches": args.scan_branches,
                    "forks": args.forks,
                    "fork_diff_bases": args.fork_diff_bases,
                    "keywords_count": len(keywords),
                },
            )

        _, hits = glh.search_keywords(
            projects=projects,
            keywords=keywords,
            options=options,
            session_file=sess_fp,
        )

        _write_jsonl_line(sess_fp, {"type": "summary", "hits": hits, "timestamp_utc": datetime.now(UTC).isoformat()})

    print(f"Session saved to: {session_path}")
    print(f"Done. Keywords: {len(keywords)} | Hits: {hits}")


if __name__ == "__main__":
    main()
